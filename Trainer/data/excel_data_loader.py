"""Excel data loader for poker hand ranges from generated Excel files."""

import pandas as pd
import os
from typing import Dict, List, Tuple, Set
from pathlib import Path

class ExcelDataLoader:
    """Loads poker hand range data from Excel files generated by the visualization system."""
    
    def __init__(self, base_path: str = None):
        """Initialize the Excel data loader.
        
        Args:
            base_path: Base path to the Excel files. If None, uses default path.
        """
        if base_path is None:
            # Default path to the generated Excel files
            self.base_path = Path(__file__).parent.parent.parent / "Poker_Hand" / "src" / "visualization" / "output"
        else:
            self.base_path = Path(base_path)
        
        self._cache = {}  # Cache loaded data for performance
    
    def get_available_table_sizes(self) -> List[str]:
        """Get available table sizes (6-max, 9-max)."""
        table_sizes = []
        if (self.base_path / "6_player" / "6max_ranges.xlsx").exists():
            table_sizes.append("6-max")
        if (self.base_path / "9_player" / "9max_ranges.xlsx").exists():
            table_sizes.append("9-max")
        return table_sizes
    
    def get_positions_for_table_size(self, table_size: str) -> List[str]:
        """Get available positions for a specific table size.
        
        Args:
            table_size: Either '6-max' or '9-max'
            
        Returns:
            List of position names
        """
        if table_size == "6-max":
            return ["UTG", "HJ", "CO", "BTN", "SB", "BB"]
        elif table_size == "9-max":
            return ["UTG", "UTG1", "MP1", "MP2", "HJ", "CO", "BTN", "SB", "BB"]
        else:
            return []
    
    def get_available_actions(self) -> List[str]:
        """Get available actions for training."""
        return ["Opening-Raise", "3-Bet", "4-Bet"]
    
    def _get_excel_file_path(self, table_size: str) -> Path:
        """Get the path to the Excel file for a specific table size."""
        if table_size == "6-max":
            return self.base_path / "6_player" / "6max_ranges.xlsx"
        elif table_size == "9-max":
            return self.base_path / "9_player" / "9max_ranges.xlsx"
        else:
            raise ValueError(f"Unknown table size: {table_size}")
    
    def _load_excel_data(self, table_size: str) -> Dict:
        """Load data from Excel file for a specific table size.
        
        Args:
            table_size: Either '6-max' or '9-max'
            
        Returns:
            Dictionary with position -> action -> hand_set mapping
        """
        cache_key = table_size
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        excel_path = self._get_excel_file_path(table_size)
        
        if not excel_path.exists():
            print(f"Warning: Excel file not found at {excel_path}")
            return {}
        
        try:
            # Read all sheets from the Excel file
            excel_data = pd.read_excel(excel_path, sheet_name=None)
            
            parsed_data = {}
            
            for position, df in excel_data.items():
                if df.empty:
                    continue
                    
                parsed_data[position] = {}
                
                # Get column names (actions)
                action_columns = [col for col in df.columns if col != 'Hand']
                
                for action in action_columns:
                    if action in df.columns:
                        # Get hands where the action is "YES"
                        yes_hands = df[df[action] == 'YES']['Hand'].tolist()
                        parsed_data[position][action] = set(yes_hands)
                    else:
                        parsed_data[position][action] = set()
            
            # Cache the parsed data
            self._cache[cache_key] = parsed_data
            return parsed_data
            
        except Exception as e:
            print(f"Error loading Excel file {excel_path}: {e}")
            return {}
    
    def get_playable_hands(self, table_size: str, position: str, action: str) -> Set[str]:
        """Get the set of playable hands for a specific position and action.
        
        Args:
            table_size: Either '6-max' or '9-max'
            position: Position name (e.g., 'UTG', 'BTN')
            action: Action type (e.g., 'Opening-Raise', '3-Bet')
            
        Returns:
            Set of playable hands
        """
        data = self._load_excel_data(table_size)
        
        if position not in data:
            return set()
        
        if action not in data[position]:
            return set()
        
        return data[position][action]
    
    def should_play_hand(self, table_size: str, position: str, action: str, hand: str) -> bool:
        """Check if a specific hand should be played in the given scenario.
        
        Args:
            table_size: Either '6-max' or '9-max'
            position: Position name
            action: Action type
            hand: Hand to check (e.g., 'AA', 'AKs', 'AKo')
            
        Returns:
            True if hand should be played, False otherwise
        """
        playable_hands = self.get_playable_hands(table_size, position, action)
        return hand in playable_hands
    
    def get_all_hands(self) -> List[str]:
        """Get all possible poker hands in standard format.
        
        Returns:
            List of all poker hands (pairs, suited, offsuit)
        """
        ranks = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2']
        all_hands = []
        
        # Pairs
        for rank in ranks:
            all_hands.append(rank + rank)
        
        # Suited and offsuit hands
        for i in range(len(ranks)):
            for j in range(i + 1, len(ranks)):
                all_hands.append(ranks[i] + ranks[j] + 's')
                all_hands.append(ranks[i] + ranks[j] + 'o')
        
        return sorted(all_hands)
    
    def get_training_hands_for_scenario(self, table_size: str, position: str, action: str) -> List[Tuple[str, str, bool]]:
        """Get all hands with their correct answers for a training scenario.
        
        Args:
            table_size: Either '6-max' or '9-max'
            position: Position name
            action: Action type
            
        Returns:
            List of (hand, position_display, should_play) tuples
        """
        all_hands = self.get_all_hands()
        playable_hands = self.get_playable_hands(table_size, position, action)
        
        training_hands = []
        position_display = f"{position} ({table_size} {action})"
        
        for hand in all_hands:
            should_play = hand in playable_hands
            training_hands.append((hand, position_display, should_play))
        
        return training_hands
    
    def validate_data_integrity(self) -> Dict[str, bool]:
        """Validate the integrity of loaded Excel data.
        
        Returns:
            Dictionary with validation results
        """
        results = {}
        
        for table_size in ["6-max", "9-max"]:
            try:
                data = self._load_excel_data(table_size)
                results[f"{table_size}_loaded"] = len(data) > 0
                
                if data:
                    # Check if all expected positions exist
                    expected_positions = self.get_positions_for_table_size(table_size)
                    all_positions_exist = all(pos in data for pos in expected_positions)
                    results[f"{table_size}_all_positions"] = all_positions_exist
                    
                    # Check if all actions have data
                    has_action_data = False
                    for position_data in data.values():
                        if any(len(hands) > 0 for hands in position_data.values()):
                            has_action_data = True
                            break
                    results[f"{table_size}_has_action_data"] = has_action_data
                
            except Exception as e:
                results[f"{table_size}_error"] = str(e)
        
        return results
